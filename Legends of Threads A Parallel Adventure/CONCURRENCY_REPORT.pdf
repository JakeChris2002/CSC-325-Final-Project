Concurrency in Legends of Threads

Jake Blankenship

The game Legends of Threads demonstrates how concurrency allows

many parts of a program to run at the same time while still

working together safely. Concurrency is important in modern

programming because it helps software stay responsive and

efficient. 

In this game, each major component runs in its own thread, 

which allows characters, background systems, and the main game 

loop to operate independently. However, because these threads 

share information and resources, the program must carefully 

control how they interact. The project uses several tools and 

strategies to make sure the threads work smoothly without 

causing errors.

The main application thread is the center of the game. 

It handles player input, initializes the game world, 

and manages the turn-based system. Since the main thread 

decides when the player and AI characters may act, 

it plays a key role in coordinating the activities of all the 

other threads. Without this central control, the different 

parts of the program could run out of order, causing confusion 

or incorrect behavior.

Each character in the game also runs in its own separate thread. 

The Knight, Thief, and Wizard all operate independently, and 

the player’s character responds to direct user input. 

The AI-controlled characters make their own decisions and 

perform actions in a continuous loop. Because these character 

threads access the same shared world such as the treasure 

vault, the mana pool, or the loot system they must do so 

carefully. If two characters try to change the same information 

at the same time, the game could produce incorrect results or 

even crash.

To support the game world, there are also several background 

service threads. These include threads that generate treasure, 

monitor the system’s status, and distribute loot items. They 

keep the world active by constantly adding new resources and 

ensuring that the system is running properly. Without these 

background tasks, the game would feel empty or unresponsive.

A major challenge in any concurrent system is the possibility 

of race conditions. A race condition happens when two or more 

threads try to change the same data at the same time, leading 

to mistakes or inconsistent values. One example in Legends of 

Threads is the shared treasure vault. If multiple characters 

try to take treasure at once, the amount stored in the vault 

could become wrong. To prevent this, the program uses a 

read-write lock. This allows many threads to read the vault’s 

contents but ensures that only one thread at a time can update 

it. This keeps the treasure count accurate even during heavy 

activity.

The global mana pool is another shared resource that needs 

protection. Without safeguards, multiple Wizard characters 

could use or restore mana at the same moment and cause the 

value to update incorrectly. To solve this, the game uses an 

atomic variable, which ensures that changes to the mana happen 

safely and in the correct order, even when many threads are 

active.

The loot system also requires careful handling. Characters 

take loot from a shared queue, and without protection they 

might take the same item or receive an error when no loot is 

available. To control this, the program uses a blocking queue. 

This type of queue is thread-safe and automatically makes 

threads wait when there is no loot available, preventing many 

common errors.

Even each character’s private data, such as health and alive 

status, must be protected from unsafe access. A character might 

take damage, level up, or change equipment while another 

thread is reading or modifying that same information. For this 

reason, every character has its own lock to make sure only one 

thread can update its state at a time.

The game also includes coordination strategies that help the 

threads interact in an organized way. When it is the player’s 

turn, AI threads pause so they do not act at the same time as 

the player. This keeps the turn-based gameplay clear and fair. 

The program also uses a careful shutdown process that waits for 

threads to finish their work and interrupts them if needed. 

This prevents the application from freezing or leaving 

background threads running after the game ends.

Overall, Legends of Threads is an effective example of how 

concurrency can be used in a game environment. By using locks, 

atomic variables, thread-safe queues, and clear coordination 

rules, the game allows many actions to happen at once while 

still protecting shared data and preventing errors. 

The project shows how careful design can make a multi-threaded 

system both dynamic and stable, providing a smooth gaming 

experience and demonstrating important concepts in concurrent 

programming.
